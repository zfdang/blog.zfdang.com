[{"title":"闲话架构","date":"2019-01-09T07:14:05.000Z","path":"2019/01/notes-about-architecture/","text":"到底什么是架构？软件架构到底是为了什么，要做什么？ 架构为了业务抛开业务谈架构，是没有价值的，架构不能离开业务单独存在。 因为业务的不同，架构也是多种多样。 架构的最终目标，是为了支撑业务，不能满足业务发展的架构，不是一个好架构 架构为了协作架构的目的，是为了使得团队规模变大时成员间的协作也能够顺利进行。如果一个团队，就那么几个人，那么讨论不同架构的价值意义很小。这时候，可能一个单体应用，是最适合的方法。 当团队规模变大时，我们需要在架构上将不同成员的工作解耦，使得每个人可以相对独立的完成自己的工作，而不用相互之间有很强的依赖性。 所以架构的要求，要能做到解耦，从而使得协作变得容易。 架构需要不断演化公司的业务和团队的规模总是在不断的变化。这种变化，使得架构要解决的问题也总是不一样的，所以架构要不断的演化。 不存在这么一个理想的架构，它在公司不同的发展阶段都是最好的。 架构要演化，就需要投入。 好的架构要能做到未雨绸缪，提前做好变化，从而能迎接团队、业务的变化。","tags":[]},{"title":"使用Fresco库时，显示超大图片时效果差的解决方法","date":"2018-12-11T09:37:34.000Z","path":"2018/12/fix-low-rendering-quality-issue-for-large-image-while-using-fresco/","text":"使用Fresco来处理和显示图片很方便。可是最近遇到一个问题，Fresco显示大图片时，效果特别差，模糊感特别强烈。 后来终于找到了解决办法： https://github.com/facebook/fresco/issues/916 Fresco’s max supported width/height in resizingIf you ResizeOptions, the converted one has a max size of 2048px, which makes wide or long image’s quality low. If you can cut the source into smaller one, its quality will be better. 后来Fresco改进了ResizeOptions了，可以设置maxBitmapSize了。 https://frescolib.org/javadoc/reference/com/facebook/imagepipeline/common/ResizeOptions.html 如果不担心收到的图片过于大的话，下面这个方法就很简单粗暴了： ImageRequestBuilder.newBuilderWithSource(Uri.parse(uri)).setResizeOptions(new ResizeOptions(Integer.MAX_VALUE, Integer.MAX_VALUE, Integer.MAX_VALUE))` 注意: 如果开启了硬件加速，android的OpenGL对图片的最大尺寸有要求。如果超过这个最大的size，图片直接显示空白，程序也不会报错。 参见： https://stackoverflow.com/questions/15313807/android-maximum-allowed-width-height-of-bitmap https://stackoverflow.com/questions/7428996/hw-accelerated-activity-how-to-get-opengl-texture-size-limit 解决方法就是把图片动态切成多个小图，显示成多个图片，然后拼接在一起。 这里有一个例子： https://github.com/zfdang/zSMTH-Android/blob/master/app/src/main/java/com/zfdang/zsmth_android/fresco/WrapContentDraweeView.java","tags":[]},{"title":"monorepo的讨论","date":"2018-10-24T07:42:23.000Z","path":"2018/10/monolithic-repository/","text":"所谓“天下大事，分久必合合久必分”，如今在代码库的管理上，也出现了这种争论：到底是使用多个代码库呢，还是使用单个的代码库？ multiple repositories v.s. monolithic repository monorepo的代表，有Google, Facebook等一众高大上的公司。 这里有几篇文章，供大家借鉴： Advantages of monorepos Why We Should Use Monolithic Repositories Why We Should Not Return to Monolithic Repositories 大家的意见呢？","tags":[]},{"title":"从百度云盘快速下载文件","date":"2018-10-16T08:50:58.000Z","path":"2018/10/download-from-baidu-pan/","text":"百度云盘在经历过免费期后，现在对非付费用户的下载限速非常狠，经常只有10k左右，还经常下载失败。 码农肯定不会付钱买服务的，呵呵，所以就有快速下载百度云盘的方法出来了： 先安装Aria2 Gui for Machttps://github.com/yangshun1029/aria2gui 再在Chrome里安装百度Exporterhttps://github.com/acgotaku/BaiduExporter 下载的时候，先创建公开的分享，然后在分享的页面，就会出现导出到Aria2的按钮了 回到Aria2就可以看到下载的状态了:","tags":[]},{"title":"黄花城水长城","date":"2018-10-08T05:24:01.000Z","path":"2018/10/great-wall-in-water/","text":"从长城俯瞰水库","tags":[]},{"title":"MacOS下Cisco AnyConnect频繁要求管理员权限的解决方法","date":"2018-09-23T06:50:35.000Z","path":"2018/09/anyconnect-ask-for-permission-in-macos/","text":"MacOS下，Cisco AnyConnect客户端，经常要求输入管理员密码，并且没办法记住用户名或者密码，特别讨厌。 Mac OS wants to make changes. Type an administrator’s name and password to allow this: 后来终于找到了解决的方法： https://discussions.apple.com/thread/6995022 • Launch /Applications/Utilities/Keychain Access • Select “System” from the Keychains menu in the upper left • Select “Certificates” from the Category menu in the lower left • Find the entry that corelates to your computer’s name in the list on the right, and click on the disclosure triangle. • Secondary click on the “Private Key” entry that appears and select “Get Info” from the contextual menu that appears. • Select the Access Control tab. • You can then either add AnyConnect to the the list at the bottom of the screen (more secure, but you will need to repeat this process anytime the version of AnyConnect changes), or toggle the radio button to “Allow all applications to access this item”. 如下图： 完美解决！","tags":[]},{"title":"使用Github和Hexo来建立个人Blog","date":"2018-09-23T06:22:23.000Z","path":"2018/09/Blog-based-on-Github-and-Hexo/","text":"之前的Blog服务器被干掉了，结果数据还没有备份，有点坑爹了~~~ 重新开始! 现在github的repo, 支持使用repo中的/docs/目录作为项目主页，用Hexo来建立blog就非常方便了，如果想偷懒的话根本不需要deploy的步骤了。 修改hexo的输出目录修改_config.yml中的输出目录: public_dir: docs 然后 “/docs/“下面增加CNAME文件，指定blog的地址， 如 “blog.zfdang.com” $ hexo g 把repo push到github上 修改github repo的设置 收工！","tags":[]},{"title":"Hello World","date":"2018-09-22T06:00:00.000Z","path":"2018/09/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]},{"title":"android处理图片的一些问题总结","date":"2013-03-12T01:20:41.000Z","path":"2013/03/summary-of-image-processing-in-android/","text":"第一个问题是out of memory java.lang.OutOfMemoryError: bitmap size exceeds VM budget 这个据说是VM对一个程序申请的所有的bitmap对象会有一个最大值的要求。解决这个问题有几个方法： 从源文件生成图片时，直接将图片缩小，而不是加载原始大小的图片。如下代码： BitmapFactory.Options o = null; Bitmap bitmap = null; // decode image size (decode metadata only, not the whole image) o = new BitmapFactory.Options(); o.inJustDecodeBounds = true; stream = new FileInputStream(filename); BitmapFactory.decodeStream(stream, null, o); stream.close(); // get original image size int inWidth = o.outWidth; int inHeight = o.outHeight; clog(String.format(&quot;Original bitmap size: (%dx%d).&quot;, inWidth, inHeight)); // get size for pre-resized image o = new BitmapFactory.Options(); o.inSampleSize = Math.max(inWidth/targetWidth, inHeight/targetHeight); // decode pre-resized image stream = new FileInputStream(filename); // o.inPurgeable = true; bitmap = BitmapFactory.decodeStream(stream, null, o); stream.close(); clog(String.format(&quot;Resized bitmap size: (%dx%d).&quot;, bitmap.getWidth(), bitmap.getHeight())); 这里有一个真实的例子： https://github.com/zfdang/asm-android-client-for-newsmth/blob/master/src/com/koushikdutta/urlimageviewhelper/UrlImageViewHelper.java 及时删除不需要使用的bitmap对象，不要将所有的对象都cache住 增加程序的heap size。从某个版本开始，android manifest文件里有一个新的属性了： android:largeHeap=&quot;true&quot; android:largeHeap Whether your application’s processes should be created with a large Dalvik heap. This applies to all processes created for the application. It only applies to the first application loaded into a process; if you’re using a shared user ID to allow multiple applications to use a process, they all must use this option consistently or they will have unpredictable results.Most apps should not need this and should instead focus on reducing their overall memory usage for improved performance. Enabling this also does not guarantee a fixed increase in available memory, because some devices are constrained by their total available memory.To query the available memory size at runtime, use the methods getMemoryClass() or getLargeMemoryClass(). 第二个问题是 Bitmap too large to be uploaded into a texture exception 这个问题下面链接有详细描述： http://stackoverflow.com/questions/7428996/hw-accelerated-activity-how-to-get-opengl-texture-size-limit 简单说就是硬件加速的时候，对图片的大小有限制。不同设备可能有不同的最大值。这个问题悲催的地方是，程序貌似没有捕获到这个exception, 结果是程序也不报错，图片也显示不出来。只有看debug log才能发现这个error message. 一个解决的方法是禁止硬件加速，简单粗暴： android:hardwareAccelerated=&quot;false&quot; android:hardwareAcceleratedWhether or not hardware-accelerated rendering should be enabled for all activities and views in this application — “true” if it should be enabled, and “false” if not. The default value is “true” if you’ve set either minSdkVersion or targetSdkVersion to “14” or higher; otherwise, it’s “false”.Starting from Android 3.0 (API level 11), a hardware-accelerated OpenGL renderer is available to applications, to improve performance for many common 2D graphics operations. When the hardware-accelerated renderer is enabled, most operations in Canvas, Paint, Xfermode, ColorFilter, Shader, and Camera are accelerated. This results in smoother animations, smoother scrolling, and improved responsiveness overall, even for applications that do not explicitly make use the framework’s OpenGL libraries.Note that not all of the OpenGL 2D operations are accelerated. If you enable the hardware-accelerated renderer, test your application to ensure that it can make use of the renderer without errors.For more information, read the Hardware Acceleration guide. 比较好的解决方法是类似google map的实现：将图片分成不同的小块，每次只加载需要的块。android提供了一个方法： http://developer.android.com/reference/android/graphics/BitmapRegionDecoder.html public void drawBitmap (Bitmap bitmap, Rect src, RectF dst, Paint paint) public Bitmap decodeRegion (Rect rect, BitmapFactory.Options options) 采取上述操作后，就可以加载很多图片，同时也可以显示超级大图了。 也有一个例子，是使用Fresco这个库来显示超长图片的： https://github.com/zfdang/zSMTH-Android/blob/master/app/src/main/java/com/zfdang/zsmth_android/fresco/WrapContentDraweeView.java 上面的例子里，图片如果过宽，先会被缩放到合适的宽度；然后根据高度和openGL支持的最大高度，把图片裁剪成多个符合要求的图，然后拼接在一起。","tags":[]}]